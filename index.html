<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>real time camera</title>
    <link rel="stylesheet" href="css/x-tag-switch.css" type="text/css">
    <link rel="stylesheet" href="css/style.css" type="text/css">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />
  </head>
  <body>

    <div id="wrapper">
      <header>
        <h1><span>rt</span>camera</h1>
        <div class="controls">
          <div id="video_controls">
            <input type="image" id="btn_cancel" src="img/icons/ic_action_cancel.png" value="cancel">
            <progress max="1" value="0"></progress>
            <input type="image" id="btn_done" src="img/icons/ic_action_done.png" value="done">
            <span id="progress_label"></span>
          </div>
        </div>
      </header>

      <div id="canvasContainer"></div>

      <ul id="instructions" class="modal non_selectable">
        <li id="press">Press the screen to take a photo or record video.</li>
        <li id="arrows">Swipe left or right to change between effects.</li>
      </ul>
      <footer class="controls">
        <input type="image" id="btnVideo" src="img/icons/ic_action_video.png" alt="video">
        <x-switch id="mode_toggle" onText="camera" offText="video"></x-switch>
        <input type="image" id="btnPhoto" src="img/icons/ic_action_photo.png" alt="photo">
      </footer>
    </div>

    <script id="vs_common" type="x-shader/x-vertex">
      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      attribute vec3 position;
      attribute vec2 uv;
    </script>

    <script id="fs_common" type="x-shader/x-fragment">
      #ifdef GL_ES
      precision mediump float;
      #endif

      /**
      
      OpenGL_ES (the OpenGL "flavour" that WebGL uses) doesn't allow to use expressions
      for array indices.
      So the following code, from http://devlog-martinsh.blogspot.com.es/2011/03/glsl-dithering.html
      has to be adapted in order to work on WebGL devices.

      vec4 dither[4];
       
      dither[0] = vec4( 1.0, 33.0, 9.0, 41.0);
      dither[1] = vec4(49.0, 17.0, 57.0, 25.0);
      dither[2] = vec4(13.0, 45.0, 5.0, 37.0);
      dither[3] = vec4(61.0, 29.0, 53.0, 21.0);
       
      float limit = 0.0;
      if(x < 4) {
        limit = (dither[x][y]+1.0)/64.0;
      }
      */
      float find_closest(int x, int y, float c0) {

        vec4 dither0 = vec4( 1.0, 33.0, 9.0, 41.0);
        vec4 dither1 = vec4(49.0, 17.0, 57.0, 25.0);
        vec4 dither2 = vec4(13.0, 45.0, 5.0, 37.0);
        vec4 dither3 = vec4(61.0, 29.0, 53.0, 21.0);

        float limit = 0.0;
        float value = 0.0;

        vec4 dither;

        if(x == 0) {
          dither = dither0;
        } else if(x == 1) {
          dither = dither1;
        } else if(x == 2) {
          dither = dither2;
        } else if(x == 3) {
          dither = dither3;
        }

        if(x < 4) {
          if(y == 0) {
            value = dither[0];
          } else if(y == 1) {
            value = dither[1];
          } else if(y == 2) {
            value = dither[2];
          } else if(y == 3) {
            value = dither[3];
          }

          limit = (value + 1.0) / 64.0;
        }

        if(c0 < limit) {
          return 0.0;
        } else {
          return 1.0;
        }
      }
    </script>

    <script id="vs" type="x-shader/x-vertex">
      uniform sampler2D map;

      varying vec2 vUv;

      void main() {

        vUv = uv;

        vec4 pos = vec4( position.xy, 0.0, 1.0 );

        gl_Position = projectionMatrix * modelViewMatrix * pos;

      }
    </script>

    <script id="fs" type="x-shader/x-fragment">
      uniform sampler2D map;

      varying vec2 vUv;
      float scale = 1.0;


      void main() {

        vec3 lum = vec3(0.299, 0.587, 0.114);
        vec3 rgb = texture2D(map, vUv).rgb;
        float grayscale = dot(rgb, lum);

        vec2 xy = gl_FragCoord.xy * scale;
        int x = int(mod(xy.x, 4.0));
        int y = int(mod(xy.y, 4.0));

        vec3 finalRGB;

        finalRGB.r = find_closest(x, y, rgb.r);
        finalRGB.g = find_closest(x, y, rgb.g);
        finalRGB.b = find_closest(x, y, rgb.b);

        gl_FragColor = vec4(finalRGB, 1.0);

      }
    </script>

    <script id="fs_bw" type="x-shader/x-fragment">
      uniform sampler2D map;

      varying vec2 vUv;

      void main() {
        vec3 finalRGB;
        vec3 rgb = texture2D(map, vUv).rgb;
        float numLevels = 4.0;

        rgb = rgb * numLevels;
        rgb = floor(rgb) / numLevels;


        gl_FragColor = vec4(rgb, 1.0);
      }
    </script>

    <script src="js/libs/x-tag-core.js"></script>
    <script src="js/libs/x-tag-switch.js"></script>

    <script src="js/libs/glmatrix.min.js"></script>
    <script src="js/libs/raf.js"></script>
    <script src="js/libs/FileSaver.js"></script>

    <script src="js/libs/Animated_GIF/omggif.js"></script>
    <script src="js/libs/Animated_GIF/NeuQuant.js"></script>
    <script src="js/libs/Animated_GIF/Animated_GIF.js"></script>

    <script src="js/libs/Hammer.js"></script>

    <script src="js/ImageEffect.js"></script>
    <script src="js/rtcamera.js"></script>

  </body>
</html>
